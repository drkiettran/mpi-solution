#include <thrust/device_vector.h>
#include <thrust/host_vector.h>
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <iostream>
#include <cmath>

// This code generated by ChatGPT ...

// Physical constants
__device__ const float G = 6.67430e-11f; // Gravitational constant

// Number of bodies and time step
const int N = 1000;
__device__ const float dt = 0.01f;

// Structure to represent 3D vectors (position, velocity, force)
struct vec3 {
    float x, y, z;

    __host__ __device__
        vec3() : x(0), y(0), z(0) {}

    __host__ __device__
        vec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}

    // Vector addition
    __host__ __device__
        vec3 operator+(const vec3& b) const {
        return vec3(x + b.x, y + b.y, z + b.z);
    }

    // Scalar multiplication
    __host__ __device__
        vec3 operator*(float scalar) const {
        return vec3(x * scalar, y * scalar, z * scalar);
    }

    // Vector subtraction
    __host__ __device__
        vec3 operator-(const vec3& b) const {
        return vec3(x - b.x, y - b.y, z - b.z);
    }

    // Vector magnitude
    __host__ __device__
        float magnitude() const {
        return sqrtf(x * x + y * y + z * z);
    }
};

// Functor to compute forces and update positions/velocities
struct nbody_functor {
    const vec3* positions;
    vec3* velocities;
    const float* masses;
    int num_bodies;

    nbody_functor(const vec3* pos, vec3* vel, const float* mass, int n)
        : positions(pos), velocities(vel), masses(mass), num_bodies(n) {}

    __device__
        void operator()(int i) const {
        vec3 pos_i = positions[i];
        vec3 force(0.0f, 0.0f, 0.0f);

        // Calculate net force on body i due to all other bodies
        for (int j = 0; j < num_bodies; ++j) {
            if (i != j) {
                vec3 pos_j = positions[j];
                vec3 diff = pos_j - pos_i;
                float dist = diff.magnitude() + 1e-10f; // avoid division by zero
                float F = (G * masses[i] * masses[j]) / (dist * dist * dist);
                force = force + diff * F;
            }
        }

        // Update velocity
        vec3 vel_i = velocities[i];
        vec3 accel = force * (1.0f / masses[i]);
        vel_i = vel_i + accel * dt;

        // Update position
        vec3 pos_new = pos_i + vel_i * dt;

        // Write updated position and velocity back
        velocities[i] = vel_i;
    }
};

int main() {
    // Create random positions, velocities, and masses
    thrust::host_vector<vec3> h_positions(N);
    thrust::host_vector<vec3> h_velocities(N);
    thrust::host_vector<float> h_masses(N);

    // Initialize random positions, velocities, and masses
    for (int i = 0; i < N; ++i) {
        h_positions[i] = vec3(rand() % 100, rand() % 100, rand() % 100);
        h_velocities[i] = vec3(rand() % 10, rand() % 10, rand() % 10);
        h_masses[i] = rand() % 100 + 1; // Avoid zero mass
    }

    // Transfer data to device
    thrust::device_vector<vec3> d_positions = h_positions;
    thrust::device_vector<vec3> d_velocities = h_velocities;
    thrust::device_vector<float> d_masses = h_masses;

    // Time steps for the simulation
    const int num_timesteps = 100;

    for (int t = 0; t < num_timesteps; ++t) {
        // Use Thrust's transform to compute the forces in parallel and update positions/velocities
        thrust::for_each(thrust::counting_iterator<int>(0),
            thrust::counting_iterator<int>(N),
            nbody_functor(thrust::raw_pointer_cast(d_positions.data()),
                thrust::raw_pointer_cast(d_velocities.data()),
                thrust::raw_pointer_cast(d_masses.data()),
                N));

        // Optional: Copy back positions to host for visualization (skip for performance)
        // thrust::copy(d_positions.begin(), d_positions.end(), h_positions.begin());
    }

    // Final positions and velocities could be copied back here if needed
    thrust::copy(d_positions.begin(), d_positions.end(), h_positions.begin());
    thrust::copy(d_velocities.begin(), d_velocities.end(), h_velocities.begin());

    // Print the final positions of a few bodies
    std::cout << "Final positions of some bodies:" << std::endl;
    for (int i = 0; i < 5; ++i) {
        std::cout << "Body " << i << ": (" << h_positions[i].x << ", " << h_positions[i].y << ", " << h_positions[i].z << ")" << std::endl;
    }

    return 0;
}
