#include <mpi.h>
#include <cmath>
#include <iostream>
#include <vector>

// GENERATED by ChatGPT

// Physical constants
const float G = 6.67430e-11f;  // Gravitational constant
const float dt = 0.01f;        // Time step
const int num_timesteps = 100; // Number of simulation steps

// Structure to represent 3D vectors (position, velocity, force)
struct vec3 {
    float x, y, z;

    vec3() : x(0.0f), y(0.0f), z(0.0f) {}
    vec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}

    // Vector addition
    vec3 operator+(const vec3& b) const {
        return vec3(x + b.x, y + b.y, z + b.z);
    }

    // Vector subtraction
    vec3 operator-(const vec3& b) const {
        return vec3(x - b.x, y - b.y, z - b.z);
    }

    // Scalar multiplication
    vec3 operator*(float scalar) const {
        return vec3(x * scalar, y * scalar, z * scalar);
    }

    // Vector magnitude
    float magnitude() const {
        return sqrt(x * x + y * y + z * z);
    }
};

// Function to compute the gravitational force between two bodies
vec3 compute_force(const vec3& pos_i, const vec3& pos_j, float mass_i, float mass_j) {
    vec3 diff = pos_j - pos_i;
    float dist = diff.magnitude() + 1e-10f; // Avoid division by zero

    float F = (G * mass_i * mass_j) / (dist * dist * dist);
    return diff * F;
}

// N-body simulation function for each process
void nbody_simulation(int rank, int size, int N) {
    // Each process gets its portion of bodies
    int local_N = N / size;
    int start_idx = rank * local_N;
    int end_idx = (rank == size - 1) ? N : (rank + 1) * local_N;

    // Local storage for the bodies this process is responsible for
    std::vector<vec3> positions(local_N);
    std::vector<vec3> velocities(local_N);
    std::vector<float> masses(local_N);

    // Initialize random positions, velocities, and masses
    for (int i = 0; i < local_N; ++i) {
        positions[i] = vec3(rand() % 100, rand() % 100, rand() % 100);
        velocities[i] = vec3(rand() % 10, rand() % 10, rand() % 10);
        masses[i] = rand() % 100 + 1;
    }

    // Arrays for gathering all bodies' positions and masses across processes
    std::vector<vec3> all_positions(N);
    std::vector<float> all_masses(N);

    // Run simulation for a fixed number of time steps
    for (int step = 0; step < num_timesteps; ++step) {
        // Gather all positions and masses across processes
        MPI_Allgather(positions.data(), local_N * sizeof(vec3), MPI_BYTE,
            all_positions.data(), local_N * sizeof(vec3), MPI_BYTE, MPI_COMM_WORLD);
        MPI_Allgather(masses.data(), local_N * sizeof(float), MPI_BYTE,
            all_masses.data(), local_N * sizeof(float), MPI_BYTE, MPI_COMM_WORLD);

        // Compute forces and update positions/velocities for local bodies
        for (int i = 0; i < local_N; ++i) {
            vec3 force(0.0f, 0.0f, 0.0f);
            for (int j = 0; j < N; ++j) {
                if (start_idx + i != j) {
                    vec3 f = compute_force(positions[i], all_positions[j], masses[i], all_masses[j]);
                    force = force + f;
                }
            }

            // Update velocity and position
            vec3 accel = force * (1.0f / masses[i]);
            velocities[i] = velocities[i] + accel * dt;
            positions[i] = positions[i] + velocities[i] * dt;
        }
    }

    // Optionally, you can gather final positions and velocities to a root process for output
    if (rank == 0) {
        std::cout << "Final positions of bodies handled by process " << rank << ":\n";
        for (int i = 0; i < local_N; ++i) {
            std::cout << "Body " << start_idx + i << ": ("
                << positions[i].x << ", " << positions[i].y << ", " << positions[i].z << ")\n";
        }
    }
}

int main(int argc, char** argv) {
    // Initialize MPI
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    const int N = 1000;  // Number of bodies

    // Run the N-body simulation
    nbody_simulation(rank, size, N);

    // Finalize MPI
    MPI_Finalize();

    return 0;
}
